---
  title: "effectOfIndividualInputs"
  output: pdf_document
  author: "Andy South"
  date: "`r Sys.Date()`"
---

# Investigation into effects of individual inputs on time to reach resistance thresholds.
# version 2 - in progress

## Based on 1000 runs with all inputs varying at once which explains the variability at particular input values.
## Within each figure the plots are divided into 6 sub-plots according to the insecticide use strategy and when the resistance threshold is reached
1. insecticide 1 : sole use
1. insecticide 2 : sole use
1. Mixture 1 : threshold reached for either insecticide in mixture
1. Mixture 2 : once threshold reached for either insecticide in mixture, switch to sole use of other until it too reaches threshold
1. Mixture 3 : threshold reached for both insecticides in mixture
1. Sequential : sole use of one insecticide, switch to other when threshold reached until it too reaches threshold

These plots show gen_cP0.2, which is the number of generations to reach 20% resistance.

Red dashed lines are a smoothed mean.

Runs where resistance thresholds have not been reached have been removed.

Previous plots showed a set of points at 1000 generations. The model is run for 500 generations, any runs which have not reached the resistance threshold by this time are given a value of 1000. This has little effect on questions of whether mixtures or sequential use is better.


```{r,echo=FALSE,results='hide'}

  library(resistance)

  outFolder <- "C:\\Dropbox\\resistanceResults\\"
  
  ## to load previously saved runs
#   load(file=paste0(outFolder,'listOutMix_1000.rda'))
#   load(file=paste0(outFolder,'listOutI1_1000.rda'))
#   load(file=paste0(outFolder,'listOutI2_1000.rda'))
  
  ## trying with the extended experiment _ex100
  experiment <- 'extended'
  load(file=paste0(outFolder,'listOutMix_ex1000.rda'))
  load(file=paste0(outFolder,'listOutI1_ex1000.rda'))
  load(file=paste0(outFolder,'listOutI2_ex1000.rda'))
  
  
```


```{r,echo=FALSE,results='hide'}
### chunk copied from sensiAnPaper1All
### now want to calculate the times to reach critical points and add them on to the input file 
### for different insecticide strategies, sequential, mix1 and mix2  
  
  
  #1) sequential : time to resistance for each insecticide in isolation
  #inputs : inAndOutI1, inAndOutI2
  #find time to criticalPoint for insecticide1
  #find time to criticalPoint for insecticide2
  #add together
  resistPointsI1 <- findResistancePoints(listOutI1, locus=1)
  resistPointsI2 <- findResistancePoints(listOutI2, locus=2)  
  
  resistPointsSeq <- resistPointsI1 + resistPointsI2
  
  
  #2) mixture1 : time to resistance for either insecticide when used in a mixture
  #inputs : inAndOutMix
  #find time to criticalPoint for EITHER insecticide in mixture  
  resistPointsMix1 <- findResistancePoints(listOutMix, locus='either')  
  #todo - to be comparable I think this should be for when resistance to BOTH insecticides is reached
  
  #3) mixture2 : when resistance to one insecticide in the mixture reached, switch to sole use of the 
  #   other until that too reaches the critical point. Record total time.
  # what I actually need to do is start with mixture find the first critical point
  # (need to know which of the insecticides it is)
  # then I need to go to the single run for the other insecticide & starting at 
  # it's current resistance point find out how many more generations to go
  #inputs : inAndOutI1, inAndOutI2, inAndOutMix
  resistPointsMix2 <- findResistancePointsMixResponsive(listOutMix, listOutI1, listOutI2)
  
  #4) mixture3 : time to resistance for both insecticides when used in a mixture
  #inputs : inAndOutMix
  #find time to criticalPoint for BOTH insecticide in mixture  
  resistPointsMix3 <- findResistancePoints(listOutMix, locus='both')
  
```

```{r,echo=FALSE,results='hide'}
### chunk copied from part of one in sensiAnPaper1All
### bind results onto input file
    
  treeInput <- listOutMix$input
  
  #input files in listOutMix, listOutIn1 & listOutI2 are the same if the runs are done with default randomSeed 
  #except that exposure will be in a.f_AB, a.f_A0 and a.f_B0 respectively (& a.m* too)
  #I could just rename one to exposure
  #BEWARE risk if future changes
  #1/2/16 don't need this now because I've saved exposure from the single original random value
  #rownames(treeInput)[rownames(treeInput)=="a.f_AB"] <- "exposure"
  
  
  #hardcode which variables to include in analysis to keep it simple and transparent
  treePredictors <- c('P_1','P_2','exposure','phi.SS1_A0','phi.SS2_0B','h.RS1_A0','h.RS2_0B','s.RR1_A0','s.RR2_0B')

  #add these for extended analysis
  if (experiment=='extended')
    treePredictors <- c(treePredictors,'maleExposureProp','correctMixDeployProp')
  
  treeInput <- treeInput[ treePredictors, ]
  
  #add an extra predictor, the lower starting freq of resistance divided by the larger
  resist_start_hi_div_lo <- ifelse( treeInput['P_1',] < treeInput['P_2',], treeInput['P_1',]/treeInput['P_2',], treeInput['P_2',]/treeInput['P_1',])
  treeInput <- rbind(treeInput,resist_start_hi_div_lo)    
  
  #20160122 add test for Ian of resistance1/resistance2
  resist_start_1_div_2 <- treeInput['P_1',]/treeInput['P_2',]
  treeInput <- rbind(treeInput,resist_start_1_div_2)   
  
  #renaming other rownames to make nicer plots
  rownames(treeInput)[rownames(treeInput)=="phi.SS1_A0"] <- "effectiveness_insecticide1"
  rownames(treeInput)[rownames(treeInput)=="phi.SS2_0B"] <- "effectiveness_insecticide2"

  rownames(treeInput)[rownames(treeInput)=="P_1"] <- "start_freq_allele1"
  rownames(treeInput)[rownames(treeInput)=="P_2"] <- "start_freq_allele2"
    
  rownames(treeInput)[rownames(treeInput)=="h.RS1_A0"] <- "dominance_allele1"
  rownames(treeInput)[rownames(treeInput)=="h.RS2_0B"] <- "dominance_allele2"
  
  rownames(treeInput)[rownames(treeInput)=="s.RR1_A0"] <- "selection_coef_allele1"
  rownames(treeInput)[rownames(treeInput)=="s.RR2_0B"] <- "selection_coef_allele2"
  
  #subsetting now done above before names prettified
  #treePredictors <- c('P_1','P_2','startResistanceRatio','exposure','effectiveness_insecticide1','effectiveness_insecticide2','h.RS1_A0','h.RS2_0B','s.RR1_A0','s.RR2_0B')
  #treeInput <- treeInput[ treePredictors, ]
  
  #get the inputs here to use in ggplot investigation of model responses to inputs
  #used in a later chunk
  ggInput <- treeInput
  
    
```  
  

## This plot shows exposure which has the most noticeable pattern.
```{r, eval=TRUE, echo=FALSE, warning=FALSE} 

  
  library(ggplot2)
  
  #uses ggInput calculated in earlier chunk
  
  #first needs to transpose rows to cols
  #ggInput_T <- t(ggInput)
    
  #function to transpose and add strategy column with the passed value
  #also add on the input columns  
  addStrategyColumn <- function(x, value, inputs){
    x <- as.data.frame( t(x) )
    x$strategy <- value
    #transpose inputs
    inputs <- as.data.frame( t(inputs) )
    #cbind onto the outputs
    x <- cbind(inputs,x)
    x
  }    
    
  resistPointsI1_T <- addStrategyColumn(resistPointsI1,"insecticide 1",ggInput) 
  resistPointsI2_T <- addStrategyColumn(resistPointsI2,"insecticide 2",ggInput)   
  resistPointsSeq_T <- addStrategyColumn(resistPointsSeq,"Sequential",ggInput) 
  resistPointsMix1_T <- addStrategyColumn(resistPointsMix1,"Mixture 1",ggInput) 
  resistPointsMix2_T <- addStrategyColumn(resistPointsMix2,"Mixture 2",ggInput) 
  resistPointsMix3_T <- addStrategyColumn(resistPointsMix3,"Mixture 3",ggInput)     

  ggInsOuts <- rbind( resistPointsI1_T, resistPointsI2_T, resistPointsSeq_T, 
                      resistPointsMix1_T, resistPointsMix2_T, resistPointsMix3_T)    
  
  #remove runs that didn't reach a resistance threshold (999), even if just for one strategy
  #>1000 excludes sequential strategy that had a 999 in
  #BEWARE would need to increase 1000 if I increase max generations in the runs
  didntReachThresh <- which(ggInsOuts$gen_cP0.5 == 999 | ggInsOuts$gen_cP0.5 > 500 |
                            ggInsOuts$gen_cP0.25 == 999 | ggInsOuts$gen_cP0.25 > 500 |
                            ggInsOuts$gen_cP0.1 == 999 | ggInsOuts$gen_cP0.1 > 500 )
  
  #subset by runs not making threshold
  ggInsOuts <- ggInsOuts[-didntReachThresh,]
  
  
  #prettify output names
  names(ggInsOuts)[names(ggInsOuts)=="gen_cP0.5"] <- "time_to_resistance0.5"
  names(ggInsOuts)[names(ggInsOuts)=="gen_cP0.25"] <- "time_to_resistance0.25"
  names(ggInsOuts)[names(ggInsOuts)=="gen_cP0.1"] <- "time_to_resistance0.1"
  
  #ggplot(diamonds, aes(x=carat, y=price, color=cut)) + geom_point() + facet_wrap( ~ cut)
  
  #cool working!
  
  #exposure has the most noticeable effect
  ggplot(ggInsOuts, aes(x=exposure, y=time_to_resistance0.25, color=strategy)) + 
    geom_point(shape=3) + 
    facet_wrap( ~ strategy) + 
    #geom_smooth(aes(x=exposure, y=gen_cP0.5, color=NULL))
    geom_smooth(colour='red', linetype='dashed',size=0.5) 
  
  #effectiveness of insecticide1 little noticeable effect
#   ggplot(ggInsOuts, aes(x=effectiveness_insecticide1, y=time_to_resistance0.25, color=strategy)) + 
#     geom_point() + 
#     facet_wrap( ~ strategy) + 
#     #geom_smooth(aes(x=effectiveness_insecticide1, y=gen_cP0.5, color=NULL)) 
#     geom_smooth(colour='red', linetype='dashed',size=0.5) 
  
  
```

## In the following plots all inputs are plotted individually, the points are coloured by exposure, which allows us to see that, even as other inputs change, low times to resistance are associated with high exposure.
```{r, eval=TRUE, echo=FALSE, fig.height=3.5} 
  
  #doing; for all inputs
  if (experiment=='extended') {
    num_inputs <- 13
    } else {
    num_inputs <- 11  
    } 
  
  names_inputs <- names(ggInsOuts)[1:num_inputs]
  
  for(i in names_inputs)
  {
    #x11()

    y <- 'time_to_resistance0.25'    
    #y <- 'time_to_resistance0.5'
    #color <- 'strategy'
    #coloring by exposure shows its effect even when other params are varying
    color <- 'exposure'    
    
    print( ggplot(ggInsOuts, aes_string(x=i, y=y, color=color)) + 
             geom_point(shape=3) + 
             facet_wrap( ~ strategy) + 
             #geom_smooth(aes_string(x=i, y=y, color=NULL)) )
             geom_smooth(colour='red', linetype='dashed',size=0.5) +
             labs(title = i))
  }

  #can I facet by particular parameter ranges ?
  #might need to create a categorical var from the range and use that to facet 
  #or subset the data for specific parameter ranges
  
```  

## Looking more closely at effect of the ratio between the level of resistance to the first insecticide divided by that of the second one. Restricting the x axis to lower values.
```{r, eval=TRUE, echo=FALSE, warning=FALSE} 

  i <- 'resist_start_1_div_2'
  color <- "start_freq_allele2"
  
  print( ggplot(ggInsOuts, aes_string(x=i, y=y, color=color)) + 
           geom_point(shape=3) + 
           facet_wrap( ~ strategy) + 
           #geom_smooth(aes_string(x=i, y=y, color=NULL)) )
           geom_smooth(colour='red', linetype='dashed',size=0.5) +
           labs(title = i) +
           xlim(0,100)
         )
    
```  

#trying a PRCC analysis using the package sensitivity
```{r, eval=TRUE, echo=FALSE, warning=FALSE, fig.height=3.5} 

  library(sensitivity)
  
# pcc(X, y, rank = FALSE, nboot = 0, conf = 0.95)
# 
# ## S3 method for class 'pcc'
# plot(x, ylim = c(-1,1), ...)
# 
# Arguments
# X a data frame containing model input variables
# y a vector containing the responses 
# rank logical. If TRUE, the analysis is done on the ranks.
# nboot the number of bootstrap replicates.
# conf the confidence level of the bootstrap confidence intervals.

  strategies <- unique(ggInsOuts$strategy)
  
  for(strategy in strategies)
  {  


    by_strategy <- ggInsOuts[ggInsOuts$strategy==strategy,]
    
    x <- by_strategy[,1:num_inputs]
    y <- by_strategy['time_to_resistance0.25']
      
    pcc_res <- pcc(x, y, rank=TRUE)
    
    #if you add bootstrap, error bars are added to the default plot & extra columns to the PRCC object
    #pcc_res <- pcc(x, y, rank=TRUE, nboot=100)
    #plot(pcc_res)
    
    #results are here I can probably rbind them together into a df that I can ggplot
    #pcc_res$PRCC
    
    to_plot <- pcc_res$PRCC
    #rename column 1 from 'original to PRCC
    names(to_plot)[1] <- 'PRCC'
    to_plot$inputs <- rownames(to_plot)  
    
    print( ggplot( to_plot, aes_string(x='inputs',y='PRCC') ) + 
             geom_point(shape=1, colour='red') +
             theme(axis.text.x = element_text(angle = 45,hjust = 1, vjust = 1)) +
             geom_hline(yintercept = 0, linetype=3) +
             ylim(-1,1) +
             ggtitle(paste(strategy,"PRCC")) +
             xlab(NULL)
          )
  }
    
```  


```{r, eval=FALSE, echo=FALSE, warning=FALSE, fig.height=3.5} 
  
#trying to find apparent anomaly in PRCC analysis
#what causes correctMixDeployProp to get a high PRCC score for I1 & 2 when its not used in those runs ??
  
tstI1 <- round(listOutI1$input,3)
tstMix <- round(listOutMix$input,3)
tstDif <- round(tstMix - tstI1,3) 


  
```

