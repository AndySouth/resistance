---
  title: "paper1_results_figs"
  output: pdf_document
  author: "Andy South"
  date: "`r Sys.Date()`"
---

# Figures for paper 1 
# version 3 - in progress

## Based on 10000 runs with all inputs varying at once which explains the variability at particular input values.

Comparing these insecticide use strategies:
1. Single use
1. Mixture 1 : threshold reached for either insecticide
1. Mixture 2 : threshold reached for either insecticide, switch to sole use of other until it too reaches threshold
1. Mixture 3 : threshold reached for both insecticides in mixture
1. Sequential : sole use of one insecticide, switch to other when threshold reached until it too reaches threshold

## Notable results

1. Time-to-resistance is lowest for single use and for the first insecticide in a mixture. Time-to-resistance is highest for the 2nd insecticide in a mixture.
1. In between these extremes, there is less difference between the alternative strategies of a) sequential and b) mixture switching to sole use. The latter takes slightly longer to reach the threshold.
1. Exposure and effectiveness seem to be the most important inputs.
1. Exposure has the greatest effect on time-to-resistance.
1. Effectiveness of the insecticides is the one input that has a notably different effect on the strategies of a) sequential and b) mixture switching to sole use. Below an effectiveness of ~0.55 to 0.6 sequential takes longer, and above this 'mixture switching to sole use' takes longer. 





```{r,echo=FALSE,results='hide'}

  library(resistance)

  outFolder <- "C:\\Dropbox\\resistanceResults\\"
  
  ## to load previously saved runs
#   load(file=paste0(outFolder,'listOutMix_1000.rda'))
#   load(file=paste0(outFolder,'listOutI1_1000.rda'))
#   load(file=paste0(outFolder,'listOutI2_1000.rda'))
  
  ## trying with the extended experiment _ex100
  experiment <- 'extended'
  
  #remember these don't have new exposure column
  load(file=paste0(outFolder,'listOutMix_ex2_10000.rda'))
  load(file=paste0(outFolder,'listOutI1_ex2_10000.rda'))
  load(file=paste0(outFolder,'listOutI2_ex2_10000.rda'))  
 
# ex10000 runs showed effect of selection    
#   load(file=paste0(outFolder,'listOutMix_ex10000.rda'))
#   load(file=paste0(outFolder,'listOutI1_ex10000.rda'))
#   load(file=paste0(outFolder,'listOutI2_ex10000.rda'))
  
  
```





```{r,echo=FALSE,results='hide'}
### calculate times to reach critical points and add them on to the input file 
### for different insecticide strategies, sequential, mix1 and mix2  
  
  
  #1) sequential : time to resistance for each insecticide in isolation
  #inputs : inAndOutI1, inAndOutI2
  #find time to criticalPoint for insecticide1
  #find time to criticalPoint for insecticide2
  #add together
  resistPointsI1 <- findResistancePoints(listOutI1, locus=1)
  resistPointsI2 <- findResistancePoints(listOutI2, locus=2)  
  resistPointsSeq <- resistPointsI1 + resistPointsI2
  
  
  #2) mixture1 : time to resistance for either insecticide when used in a mixture
  #inputs : inAndOutMix
  #find time to criticalPoint for EITHER insecticide in mixture  
  resistPointsMix1 <- findResistancePoints(listOutMix, locus='either')  
  #todo - to be comparable I think this should be for when resistance to BOTH insecticides is reached
  
  #3) mixture2 : when resistance to one insecticide in the mixture reached, switch to sole use of the 
  #   other until that too reaches the critical point. Record total time.
  # what I actually need to do is start with mixture find the first critical point
  # (need to know which of the insecticides it is)
  # then I need to go to the single run for the other insecticide & starting at 
  # it's current resistance point find out how many more generations to go
  #inputs : inAndOutI1, inAndOutI2, inAndOutMix
  resistPointsMix2 <- findResistancePointsMixResponsive(listOutMix, listOutI1, listOutI2)
  
  #4) mixture3 : time to resistance for both insecticides when used in a mixture
  #inputs : inAndOutMix
  #find time to criticalPoint for BOTH insecticide in mixture  
  resistPointsMix3 <- findResistancePoints(listOutMix, locus='both')
  
```





```{r,echo=FALSE,results='hide'}
### chunk copied from part of one in sensiAnPaper1All
### bind results onto input file
    
  treeInput <- listOutMix$input
  
  #input files in listOutMix, listOutIn1 & listOutI2 are the same if the runs are done with default randomSeed 
  #except that exposure will be in a.f_AB, a.f_A0 and a.f_B0 respectively (& a.m* too)
  #I could just rename one to exposure
  #BEWARE risk if future changes
  #1/2/16 don't need this now because I've saved exposure from the single original random value
  #rownames(treeInput)[rownames(treeInput)=="a.f_AB"] <- "exposure"
  
  
  #hardcode which variables to include in analysis to keep it simple and transparent
  treePredictors <- c('P_1','P_2','exposure','phi.SS1_A0','phi.SS2_0B','h.RS1_A0','h.RS2_0B','s.RR1_A0','s.RR2_0B')

  #add these for extended analysis
  if (experiment=='extended')
    treePredictors <- c(treePredictors,'maleExposureProp','correctMixDeployProp')
  
  treeInput <- treeInput[ treePredictors, ]
  
  #add an extra predictor, the lower starting freq of resistance divided by the larger
  resist_start_hi_div_lo <- ifelse( treeInput['P_1',] < treeInput['P_2',], treeInput['P_1',]/treeInput['P_2',], treeInput['P_2',]/treeInput['P_1',])
  treeInput <- rbind(treeInput,resist_start_hi_div_lo)    
  
  #20160122 add test for Ian of resistance1/resistance2
  resist_start_1_div_2 <- treeInput['P_1',]/treeInput['P_2',]
  treeInput <- rbind(treeInput,resist_start_1_div_2)   
  
  #renaming other rownames to make nicer plots
  rownames(treeInput)[rownames(treeInput)=="phi.SS1_A0"] <- "effectiveness_insecticide1"
  rownames(treeInput)[rownames(treeInput)=="phi.SS2_0B"] <- "effectiveness_insecticide2"

  rownames(treeInput)[rownames(treeInput)=="P_1"] <- "start_freq_allele1"
  rownames(treeInput)[rownames(treeInput)=="P_2"] <- "start_freq_allele2"
    
  rownames(treeInput)[rownames(treeInput)=="h.RS1_A0"] <- "dominance_allele1"
  rownames(treeInput)[rownames(treeInput)=="h.RS2_0B"] <- "dominance_allele2"
  
  rownames(treeInput)[rownames(treeInput)=="s.RR1_A0"] <- "selection_coef_allele1"
  rownames(treeInput)[rownames(treeInput)=="s.RR2_0B"] <- "selection_coef_allele2"
  
  
  #get the inputs here to use in ggplot investigation of model responses to inputs
  #used in a later chunk
  ggInput <- treeInput
  
    
```  
  


```{r, eval=TRUE, echo=FALSE, warning=FALSE} 
# getting data into format for ggplot
  
  library(ggplot2)
  
  #uses ggInput calculated in earlier chunk
  
  #first needs to transpose rows to cols
  #ggInput_T <- t(ggInput)
    
  #function to transpose and add strategy column with the passed value
  #also add on the input columns  
  addStrategyColumn <- function(x, value, inputs){
    x <- as.data.frame( t(x) )
    x$strategy <- value
    
    #inputs <- as.numeric(inputs)
    #transpose inputs
    inputs <- as.data.frame( t(inputs), stringsAsFactors=FALSE )
    #cbind onto the outputs
    x <- cbind(inputs,x)
    x
  }    
    
  resistPointsI1_T <- addStrategyColumn(resistPointsI1,"insecticide 1",ggInput) 
  resistPointsI2_T <- addStrategyColumn(resistPointsI2,"insecticide 2",ggInput)   
  resistPointsSeq_T <- addStrategyColumn(resistPointsSeq,"Sequential",ggInput) 
  resistPointsMix1_T <- addStrategyColumn(resistPointsMix1,"Mixture 1",ggInput) 
  resistPointsMix2_T <- addStrategyColumn(resistPointsMix2,"Mixture 2",ggInput) 
  resistPointsMix3_T <- addStrategyColumn(resistPointsMix3,"Mixture 3",ggInput)     

  ggInsOuts <- rbind( resistPointsI1_T, resistPointsI2_T, resistPointsSeq_T, 
                      resistPointsMix1_T, resistPointsMix2_T, resistPointsMix3_T)    
  
  #remove runs that didn't reach a resistance threshold (999), even if just for one strategy
  #>1000 excludes sequential strategy that had a 999 in
  #BEWARE would need to increase 1000 if I increase max generations in the runs
  didntReachThresh <- which(ggInsOuts$gen_cP0.5 == 999 | ggInsOuts$gen_cP0.5 > 500 |
                            ggInsOuts$gen_cP0.25 == 999 | ggInsOuts$gen_cP0.25 > 500 |
                            ggInsOuts$gen_cP0.1 == 999 | ggInsOuts$gen_cP0.1 > 500 )
  
  #subset by runs not making threshold
  ggInsOuts <- ggInsOuts[-didntReachThresh,]
  
  
  #prettify output names
  names(ggInsOuts)[names(ggInsOuts)=="gen_cP0.5"] <- "time_to_resistance0.5"
  names(ggInsOuts)[names(ggInsOuts)=="gen_cP0.25"] <- "time_to_resistance0.25"
  names(ggInsOuts)[names(ggInsOuts)=="gen_cP0.1"] <- "time_to_resistance0.1"
  
  #doing; for all inputs
  if (experiment=='extended') {
    num_inputs <- 13
    } else {
    num_inputs <- 11  
    }
  
  #format data in a different way to enable PRCC on difference between sequential & mix2
  #resistPointsMix2_T
  #resistPointsSeq_T
  
  #columns to remove from first
  indices1 <- which(names(resistPointsMix2_T) %in% c("gen_cP0.1","gen_cP0.5","strategy"))
  #columns to add to 2nd  
  indices2 <- which(names(resistPointsMix2_T) %in% c("gen_cP0.25"))  
  #rename column in 2nd
  tmp <- resistPointsSeq_T[indices2]
  names(tmp) <- "gen_cP0.25seq"
  
  df_diff <- cbind(resistPointsMix2_T[-indices1], tmp)
  
  #remove runs that didn't reach a resistance threshold (999), even if just for one strategy
  #>1000 excludes sequential strategy that had a 999 in
  #BEWARE would need to increase 1000 if I increase max generations in the runs
  didntReachThresh <- which( df_diff$gen_cP0.25 > 500 | df_diff$gen_cP0.25seq > 500 )
  
  #subset by runs not making threshold
  df_diff <- df_diff[-didntReachThresh,]  
  
  
  #df_diff$mix2_minus_seq0.25 <- df_diff["gen_cP0.25"] - df_diff["gen_cP0.25seq"]
  df_diff["mix2_minus_seq0.25"] <- df_diff["gen_cP0.25"] - df_diff["gen_cP0.25seq"]
  
  #TODO : later do PRCC on df_diff["mix2_minus_seq0.25"]
    
```

# Time-to-resistance across all input values

```{r, eval=TRUE, echo=FALSE, warning=FALSE} 

#names_results <- c("time_to_resistance0.5","time_to_resistance0.25","time_to_resistance0.1")
names_results <- c("time_to_resistance0.25")
  
ggSubset <- ggInsOuts[ !ggInsOuts$strategy %in% c("insecticide 2"), ]  
  
for(i in names_results)
{
  #x11()
  
  print( ggplot(ggSubset, aes_string(x='strategy',y=i, color='strategy')) + 
      #ylim(0,450) +
      coord_cartesian( ylim=c(0, 350)) +
      geom_violin(draw_quantiles = c(0.25, 0.75), show.legend=FALSE, adjust = .5 ) +
      scale_x_discrete("Resistance to which insecticide", limits=c("insecticide 1","Mixture 1","Sequential","Mixture 2","Mixture 3"), labels = c("insecticide 1"="Sole use", "Mixture 1"="1st in mix","Sequential"="2nd in sequence", "Mixture 2"="2nd in mix\nswitch to sole", "Mixture 3"="2nd in mix" ) )

  ) #end print
}  
  
```


## How time-to-resistance is effected by input values for each insecticide use strategy

```{r, eval=TRUE, echo=FALSE, fig.height=3.5} 
  

  names_inputs <- names(ggInsOuts)[1:num_inputs]
  
  ggSubset <- ggInsOuts[ !ggInsOuts$strategy %in% c("insecticide 1","insecticide 2"), ]
  
  for(i in names_inputs)
  {
    #x11()

    y <- 'time_to_resistance0.25'    
    
    #print( ggplot(ggInsOuts, aes_string(x=i, y=y, colour="strategy")) + 
    print( ggplot(ggSubset, aes_string(x=i, y=y, colour="strategy")) + 
            #points not wanted if 10000
             #geom_point(shape=3, show.legend=FALSE) + 
             #geom_smooth(colour='red', linetype='dashed',size=0.5) +
             geom_smooth(linetype='dashed',size=1) +
             #facet_wrap( ~ strategy) +
             #geom_smooth(aes_string(x=i, y=y, color=NULL)) )
             labs(title = i))
  }
  
```

## How difference in time-to-resistance between sequential and mixture2 is effected by input values

```{r, eval=TRUE, echo=FALSE, fig.height=3.5} 
  
  ggSubset <- df_diff
  
  names_inputs <- names(ggSubset)[1:num_inputs]
  
  
  for(i in names_inputs)
  {
    #x11()

    y <- "mix2_minus_seq0.25"    
    
    print( ggplot(ggSubset, aes_string(x=i, y=y)) + #, colour="strategy")) + 
            #points not wanted if 10000
             geom_point(shape=1, colour="darkblue", alpha=0.2, show.legend=FALSE) + 
             #geom_smooth(colour='red', linetype='dashed',size=0.5) +
             geom_smooth(linetype='dashed',size=1, colour="red") +
             #facet_wrap( ~ strategy) +
             #geom_smooth(aes_string(x=i, y=y, color=NULL)) )
             labs(title = i) +
             geom_hline(yintercept = 0, colour="white")
           )
  }
  
```


# PRCC difference in time-to-resistance between sequential and mixture2
```{r, eval=TRUE, echo=FALSE, warning=FALSE, fig.height=3.5} 

  
  library(sensitivity)

    
    x <- df_diff[,1:num_inputs]
    y <- df_diff["mix2_minus_seq0.25"]
      
    pcc_res <- pcc(x, y, rank=TRUE)
    
    #if you add bootstrap, error bars are added to the default plot & extra columns to the PRCC object
    #pcc_res <- pcc(x, y, rank=TRUE, nboot=100)
    #plot(pcc_res)
    
    #results are here I can probably rbind them together into a df that I can ggplot
    #pcc_res$PRCC
    
    to_plot <- pcc_res$PRCC
    #rename column 1 from 'original to PRCC
    names(to_plot)[1] <- 'PRCC'
    to_plot$inputs <- rownames(to_plot)  
    
    print( ggplot( to_plot, aes_string(x='inputs',y='PRCC') ) + 
             geom_point(shape=1, colour='red') +
             theme(axis.text.x = element_text(angle = 45,hjust = 1, vjust = 1)) +
             geom_hline(yintercept = 0, linetype=3) +
             ylim(-1,1) +
             ggtitle(paste("PRCC difference between sequential and mixture2")) +
             xlab(NULL)
          )

    
```


# PRCC analysis for time-to-resistance subsetted by each insecticide use strategy
```{r, eval=TRUE, echo=FALSE, warning=FALSE, fig.height=3.5} 

  
  library(sensitivity)
  
# pcc(X, y, rank = FALSE, nboot = 0, conf = 0.95)
# 
# Arguments
# X a data frame containing model input variables
# y a vector containing the responses 
# rank logical. If TRUE, the analysis is done on the ranks.
# nboot the number of bootstrap replicates.
# conf the confidence level of the bootstrap confidence intervals.

  strategies <- unique(ggInsOuts$strategy)
  
  for(strategy in strategies)
  {  


    by_strategy <- ggInsOuts[ggInsOuts$strategy==strategy,]
    
    x <- by_strategy[,1:num_inputs]
    y <- by_strategy['time_to_resistance0.25']
      
    pcc_res <- pcc(x, y, rank=TRUE)
    
    #if you add bootstrap, error bars are added to the default plot & extra columns to the PRCC object
    #pcc_res <- pcc(x, y, rank=TRUE, nboot=100)
    #plot(pcc_res)
    
    #results are here I can probably rbind them together into a df that I can ggplot
    #pcc_res$PRCC
    
    to_plot <- pcc_res$PRCC
    #rename column 1 from 'original to PRCC
    names(to_plot)[1] <- 'PRCC'
    to_plot$inputs <- rownames(to_plot)  
    
    print( ggplot( to_plot, aes_string(x='inputs',y='PRCC') ) + 
             geom_point(shape=1, colour='red') +
             theme(axis.text.x = element_text(angle = 45,hjust = 1, vjust = 1)) +
             geom_hline(yintercept = 0, linetype=3) +
             ylim(-1,1) +
             ggtitle(paste(strategy,"PRCC")) +
             xlab(NULL)
          )
  }
    
```  




## response of resistance thresholds to individual inputs faceted by strategy
```{r, eval=TRUE, echo=FALSE, fig.height=3.5} 
  

  names_inputs <- names(ggInsOuts)[1:num_inputs]
  
  #todo find out to take sample this doesn't work
  #ggSample <- sample(ggInsOuts,500)
  
  for(i in names_inputs)
  {
    #x11()

    y <- 'time_to_resistance0.25'    
    #y <- 'time_to_resistance0.5'
    color <- 'strategy'
    #coloring by exposure shows its effect even when other params are varying
    #color <- 'exposure'    
    
    print( ggplot(ggInsOuts, aes_string(x=i, y=y, color=color)) + 
             #points not wanted if 10000
             #geom_point(shape=3, show.legend=FALSE) + 
             geom_smooth(colour='red', linetype='dashed',size=0.5, show.legend=FALSE) +
             facet_wrap( ~ strategy) + #, show_guide = FALSE) + 
             #geom_smooth(aes_string(x=i, y=y, color=NULL)) )
             labs(title = i))
  }
  
```



## Andys questions 
1. In mixtures what causes resistance to the 2nd insecticide to arise more slowly when the first insecticide is removed from the mixture ?    



