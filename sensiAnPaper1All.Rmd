---
title: "sensiAnPaper1All"
output: html_document
---

### All code for the sensitivity analysis for the first paper

The main question is under which scenarios are mixtures better than sequential ?

This breaks down into these subsidiary quetsions :
1. Under which scenarios is the time to resistance for either insecticide quicker for 

```{r}
  library(resistance)

  outFolder <- "C:\\Dropbox\\resistanceResults\\"
```

<!-- eval=FALSE to stop slow code being executed --> 
```{r, eval=FALSE}

  #default setting of the random seed in sensiAnPaperPart() should make the input files mostly the same with exception of exposure
  
  
  nScenarios <- 100
  #nScenarios <- 10
  ## do model runs
  listOutMix <- sensiAnPaperPart( nScenarios, insecticideUsed = 'mixture' )
  listOutI1 <- sensiAnPaperPart( nScenarios, insecticideUsed = 'insecticide1' )
  listOutI2 <- sensiAnPaperPart( nScenarios, insecticideUsed = 'insecticide2' )
  
  ## save results objects as rda for re-use
  save(listOutMix, file=paste0(outFolder,'listOutMix.rda'))
  save(listOutI1, file=paste0(outFolder,'listOutI1.rda'))
  save(listOutI2, file=paste0(outFolder,'listOutI2.rda'))   
  
    
```  

```{r}
  ## to load previously saved runs, e.g. these that I added 100 onto filename
  load(file=paste0(outFolder,'listOutMix_100.rda'))
  load(file=paste0(outFolder,'listOutI1_100.rda'))
  load(file=paste0(outFolder,'listOutI2_100.rda'))
    
```


### now want to calculate the times to reach critical points and add them on to the input file 
### for different insecticide strategies, sequential, mix1 and mix2
```{r}
  #1) sequential : time to resistance for each insecticide in isolation
  #inputs : inAndOutI1, inAndOutI2
  #find time to criticalPoint for insecticide1
  #find time to criticalPoint for insecticide2
  #add together
  resistPointsI1 <- findResistancePoints(listOutI1, locus=1)
  resistPointsI2 <- findResistancePoints(listOutI2, locus=2)  
  
  resistPointsSeq <- resistPointsI1 + resistPointsI2
  
  
  #2) mixture1 : time to resistance for either insecticide when used in a mixture
  #inputs : inAndOutMix
  #find time to criticalPoint for EITHER insecticide in mixture  
  resistPointsMix1 <- findResistancePoints(listOutMix, locus='either')  
  #todo - to be comparable I think this should be for when resistance to BOTH insecticides is reached
  
  #3) mixture2 : when resistance to one insecticide in the mixture reached, switch to sole use of the 
  #   other until that too reaches the critical point. Record total time.
  # what I actually need to do is start with mixture find the first critical point
  # (need to know which of the insecticides it is)
  # then I need to go to the single run for the other insecticide & starting at 
  # it's current resistance point find out how many more generations to go
  #inputs : inAndOutI1, inAndOutI2, inAndOutMix
  
  #resistPointsMix2 <- findResistancePointsMixResponsive(listOutMix, listOutI1, listOutI2)
  
  #4) mixture3 : time to resistance for both insecticides when used in a mixture
  #inputs : inAndOutMix
  #find time to criticalPoint for BOTH insecticide in mixture  
  resistPointsMix3 <- findResistancePoints(listOutMix, locus='both')
  
```
  
### calculate the difference between sequential & mixture scenarios
```{r}
  
  require('plyr')
  
  ## is mix1 better than sequential ?
  #T/F
  resistBetterMix1SeqBoolean <- resistPointsMix1 > resistPointsSeq
  #convert to 0/1
  resistBetterMix1Seq <- plyr::aaply(resistBetterMix1SeqBoolean,.margins=c(1,2),.fun=as.numeric)
  #rename rows ready for binding on to inputs
  rownames(resistBetterMix1Seq) <- gsub('gen','betterMix1Seq', rownames(resistBetterMix1Seq))
  
  #in 100 runs for all 3 critical points sequential was better than mix1 all the time
  
  ## is mix3 better than sequential ?
  #T/F
  resistBetterMix3SeqBoolean <- resistPointsMix3 > resistPointsSeq
  #convert to 0/1
  resistBetterMix3Seq <- plyr::aaply(resistBetterMix3SeqBoolean,.margins=c(1,2),.fun=as.numeric)
  #rename rows ready for binding on to inputs
  rownames(resistBetterMix3Seq) <- gsub('gen','betterMix3Seq', rownames(resistBetterMix3Seq))
  
  #in 100 runs only one critical point run combination was mix3 better
  
  #check1
  #plot the 2 individual results & the mixture, just to check what is going on
  #the mixture one looks superficially similar to the individual ones superimposed
  #x11()
  plotallele.freq.andy(listOutMix)
  #x11()
  plotallele.freq.andy(listOutI1)
  #x11()
  plotallele.freq.andy(listOutI2)
  
  #I should be able to compare single scenarios
  #yes this works, but not too useful
  plotallele.freq.andy( list(results=list(listOutMix$results[[1]], listOutI1$results[[1]] )) )
  #this is a modifdeied version of Beths function
  #allowing curtis fig2 to be applied to any scenario
  plotcurtis_f2_generic( listOutMix$results[[1]], listOutI2$results[[1]], listOutI1$results[[1]] )
  
  #check2
  #what is the absolute difference between mix3 & sequential ?
  #looks plausible
  resistDifferenceMix3Seq <- resistPointsMix3 - resistPointsSeq
  
  #check3 is their a difference between the mix & the individual strategies
  #looks mostly plausible, occasionally there are 0s
  resistDifferenceMix1I1 <- resistPointsMix1 - resistPointsI1
  resistDifferenceMix1I2 <- resistPointsMix1 - resistPointsI2  
  
  ## is mix2 better than sequential ?  
  # I might expect it to be similar to mix3
  
  
  # comparing sensitivity inputs to those used by Beth to reproduce curtis fig2
  inputCurtis <- createInputMatrix(FALSE)
  inputSensiMix <- listOutMix$input
  
  input <- cbind(inputCurtis, inputSensiMix)
  write.csv(input, file=paste0(outFolder,'inputCurtisSensiCompare.csv'))
  
  
```



  
  
### bind results onto input file
```{r}
  
  treeInput <- listOutMix$input
  
  #input files in listOutMix, listOutIn1 & listOutI2 are the same if the runs are done with default randomSeed 
  #except that exposure will be in a.f_AB, a.f_A0 and a.f_B0 respectively (& a.m* too)
  #I could just rename one to exposure
  rownames(treeInput)[rownames(treeInput)=="a.f_AB"] <- "exposure"
  
  #hardcode which variables to include in the tree analysis here
  #to keep it simple and transparent
  treePredictors <- c('P_1','P_2','exposure','phi.SS1_A0','phi.SS2_0B','h.RS1_A0','h.RS2_0B','s.RR1_A0','s.RR2_0B')
  treeInput <- treeInput[ treePredictors, ]
  


  treeInput <- rbind( treeInput, resistBetterMix1Seq )
  #todo add other results rows here  
  
```
  
### do tree analysis
```{r, eval=FALSE}
  require(rpart)
  
  #transpose
  treeInput <- t(treeInput)
  #convert to a dataframe
  treeInput <- data.frame(treeInput)
  
  treePredictorString <- paste(treePredictors, collapse="+")
  treeResponse <- 'betterMix1Seq_cP0.5'
  
  #at 0.5 level
  tree <- rpart::rpart(as.formula(paste(treeResponse,"~",treePredictorString)), data = treeInput, method = 'class') 
  #getting error number of rows of matrices must match (see arg 2)
  #may be becuase all vals are 0 ??
  #yes when I added some 1s it worked OK
  #treeInput$betterMix1Seq_cP0.5[1:5] <- 1
  
  
  #using as.formula
  #tree <- rpart::rpart(as.formula(paste("res ~",argString)), data = inputAndResults, method = 'class')  
  #hardcoded args
  #tree <- rpart(res ~ h.RS1_A0 + h.RS2_0B, data = inputAndResults, method = 'class')
  #tree <- rpart(betterMix1Seq_cP0.5 ~ h.RS1_A0 + h.RS2_0B, data = treeInput, method = 'class')  
  
  
  plot(tree) #plots tree
  text(tree) #labels tree
    
    #pruning tree
    #   treePruned <- prune(tree, cp=tree$cptable[which.min(tree$cptable[,"xerror"]),"CP"])
    #   plot(treePruned) #plots tree
    #   text(treePruned) #labels tree 
  
```  
